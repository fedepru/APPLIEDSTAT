col = 'blue',
ylim = c(0, 1),
xlab = 'x',
ylab = 'estimated posterior',
main = "LDA",
xlim = range(Infg)
)
points(Infg[B], rep(0, length(B)), pch = 16, col = 'red')
abline(v = 0, col = 'grey')
points(
c(0, 0),
c(predict(cyto.lda, data.frame(Infg = 0))$posterior),
col = c('blue', 'red'),
pch = '*',
cex = 2.5
)
predict(cyto.lda, x)$class
lines(
x[, 1],
cyto.LDA.A,
type = 'l',
col = 'blue',
xlab = 'x',
ylab = 'estimated posterior',
main = "LDA"
)
lines(x[, 1], cyto.LDA.B, type = 'l', col = 'red')
abline(h = 0.5)
legend(
-10,
0.9,
legend = c('P(A|X=x)', 'P(B|X=x)'),
fill = c('blue', 'red'),
cex = 0.7
)
}
# R LDA function
library(MASS)
help(lda)
cyto.lda <- lda(group ~ Infg)
cyto.lda
# posterior probability and classification for x=0
x <- data.frame(Infg = 0)
# The command predict() returns a list containing (see the help of predict.lda):
# - the class associated with the highest posterior probability
predict(cyto.lda, x)$class
# - the posterior probabilities for the classes
predict(cyto.lda, x)$posterior
# - in lda: the coordinates of the canonical analysis of Fisher
#           (Fisher's discriminant scores)
predict(cyto.lda, x)$x
# posterior probability for a grid of x's
x <- data.frame(Infg = seq(-10, 35, 0.5))
head(predict(cyto.lda, x)$posterior)
cyto.LDA.A <-
predict(cyto.lda, x)$posterior[, 1] # posterior probability for class A
cyto.LDA.B <-
predict(cyto.lda, x)$posterior[, 2] # posterior probability for class B
plot.pred.lda <- function() {
plot(
Infg[A],
rep(0, length(A)),
pch = 16,
col = 'blue',
ylim = c(0, 1),
xlab = 'x',
ylab = 'estimated posterior',
main = "LDA",
xlim = range(Infg)
)
points(Infg[B], rep(0, length(B)), pch = 16, col = 'red')
abline(v = 0, col = 'grey')
points(
c(0, 0),
c(predict(cyto.lda, data.frame(Infg = 0))$posterior),
col = c('blue', 'red'),
pch = '*',
cex = 2.5
)
predict(cyto.lda, x)$class
lines(
x[, 1],
cyto.LDA.A,
type = 'l',
col = 'blue',
xlab = 'x',
ylab = 'estimated posterior',
main = "LDA"
)
lines(x[, 1], cyto.LDA.B, type = 'l', col = 'red')
abline(h = 0.5)
legend(
-10,
0.9,
legend = c('P(A|X=x)', 'P(B|X=x)'),
fill = c('blue', 'red'),
cex = 0.7
)
}
plot.pred.lda()
# set prior probabilities
# Pay attention to the order in which the levels appear in factor(group)!
cyto.lda.1 <- lda(group ~ Infg, prior=c(0.95, 0.05))
cyto.lda.1
x <- data.frame(Infg=seq(-10, 35, 0.5))
cyto.LDA.A.1 <- predict(cyto.lda.1, x)$posterior[,1] # posterior probability for class A
cyto.LDA.B.1 <- predict(cyto.lda.1, x)$posterior[,2] # posterior probability for class B
plot  (x[,1], cyto.LDA.A.1, type='l', col='blue', xlab='x', ylab='estimated posterior', main="LDA", ylim=c(0,1))
points(x[,1], cyto.LDA.B.1, type='l', col='red')
abline(h = 0.5)
legend(-10, 0.9, legend=c('P(A|X=x)', 'P(B|X=x)'), fill=c('blue','red'), cex = 0.7)
points(Infg[A], rep(0, length(A)), pch=16, col='blue')
points(Infg[B], rep(0, length(B)), pch=16, col='red')
points(x[,1], cyto.LDA.A, type='l', col='grey')
points(x[,1], cyto.LDA.B, type='l', col='grey')
## Comparison with k-Nearest Neighbor (k-NN) classifier ----------------------------------------
library(class)
help(knn)
cyto.knn <- knn(train = Infg, test = x, cl = group, k = 3, prob = T)
cyto.knn.class <- cyto.knn == 'B'
cyto.knn.B <- ifelse(cyto.knn.class==1,
attributes(cyto.knn)$prob,
1 - attributes(cyto.knn)$prob)
plot(x[,1], cyto.LDA.B, type='l', col='red', lty=2, xlab='x', ylab='estimated posterior')
points(x[,1], cyto.knn.B, type='l', col='black', lty=1)
abline(h = 0.5)
legend(-10, 0.75, legend=c('LDA','knn'), lty=c(2,1), col=c('red','black'))
# let's change k
par(mfrow=c(3, 4))
for(k in 1:12)
{
cyto.knn <- knn(train = Infg, test = x, cl = group, k = k, prob=T)
cyto.knn.class <- (cyto.knn == 'B')+0
cyto.knn.B <- ifelse(cyto.knn.class==1, attributes(cyto.knn)$prob, 1 - attributes(cyto.knn)$prob)
plot(x[,1], cyto.LDA.B, type='l', col='red', lty=2, xlab='x', ylab='estimated posterior', main=k)
points(x[,1], cyto.knn.B, type='l', col='black', lty=1, lwd=2)
abline(h = 0.5)
}
help(iris)
attach(iris)
species.name <- factor(Species)
g = 3
i1 <- which(species.name == 'setosa')
i2 <- which(species.name == 'versicolor')
i3 <- which(species.name == 'virginica')
n1 <- length(i1)
n2 <- length(i2)
n3 <- length(i3)
n <- n1 + n2 + n3
detach(iris)
iris2 <- iris[,1:2]
# Jittering
set.seed(1)
iris2 <- iris2 + cbind(rnorm(150, sd=0.025))    # jittering
# Plot the data to verify assumptions
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=19)
points(iris2[i1,], col='red', pch=19)
points(iris2[i2,], col='green', pch=19)
points(iris2[i3,], col='blue', pch=19)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'))
m <-  colMeans(iris2)
m1 <- colMeans(iris2[i1, ])
m2 <- colMeans(iris2[i2, ])
m3 <- colMeans(iris2[i3, ])
iris2 <- iris2 + cbind(rnorm(150, sd=0.025))    # jittering
# Plot the data to verify assumptions
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=19)
points(iris2[i1,], col='red', pch=19)
points(iris2[i2,], col='green', pch=19)
points(iris2[i3,], col='blue', pch=19)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'))
m <-  colMeans(iris2)
m1 <- colMeans(iris2[i1, ])
m2 <- colMeans(iris2[i2, ])
m3 <- colMeans(iris2[i3, ])
{
cyto.knn <- knn(train = Infg, test = x, cl = group, k = k, prob=T)
cyto.knn.class <- (cyto.knn == 'B')+0
cyto.knn.B <- ifelse(cyto.knn.class==1, attributes(cyto.knn)$prob, 1 - attributes(cyto.knn)$prob)
plot(x[,1], cyto.LDA.B, type='l', col='red', lty=2, xlab='x', ylab='estimated posterior', main=k)
points(x[,1], cyto.knn.B, type='l', col='black', lty=1, lwd=2)
abline(h = 0.5)
}
par(mfrow=c(1, 1))
detach(cyto)
help(iris)
attach(iris)
species.name <- factor(Species)
g = 3
i1 <- which(species.name == 'setosa')
i2 <- which(species.name == 'versicolor')
i3 <- which(species.name == 'virginica')
n1 <- length(i1)
n2 <- length(i2)
n3 <- length(i3)
n <- n1 + n2 + n3
detach(iris)
iris2 <- iris[,1:2]
# Jittering
set.seed(1)
iris2 <- iris2 + cbind(rnorm(150, sd=0.025))    # jittering
# Plot the data to verify assumptions
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=19)
points(iris2[i1,], col='red', pch=19)
points(iris2[i2,], col='green', pch=19)
points(iris2[i3,], col='blue', pch=19)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'))
m <-  colMeans(iris2)
m1 <- colMeans(iris2[i1, ])
m2 <- colMeans(iris2[i2, ])
m3 <- colMeans(iris2[i3, ])
S1 <- cov(iris2[i1, ])
S2 <- cov(iris2[i2, ])
S3 <- cov(iris2[i3, ])
Sp  <- ((n1 - 1) * S1 + (n2 - 1) * S2 + (n3 - 1) * S3) / (n - g)
# One-way MANOVA
fit <- manova(as.matrix(iris2) ~ species.name)
summary.manova(fit, test="Wilks")
# Linear Discriminant Analysis (LDA)
lda.iris <- lda(iris2, species.name)
lda.iris
Lda.iris <- predict(lda.iris, iris2)
names(Lda.iris)
# 1) Compute the APER
Lda.iris$class   # assigned classes
species.name     # true labels
table(class.true=species.name, class.assigned=Lda.iris$class)
errors <- (Lda.iris$class != species.name)
errors
sum(errors)
length(species.name)
APER   <- sum(errors)/length(species.name)
APER
(1+14+15)/150
# Recall: LOO CV
errors_CV <- 0
for(i in 1:150){
LdaCV.i <- lda(iris2[-i,], species.name[-i], prior=c(50, 50, 50) / 150)
errors_CV <- errors_CV + as.numeric(predict(LdaCV.i,iris2[i,])$class != species.name[i])
}
errors_CV
AERCV   <- sum(errors_CV)/length(species.name)
AERCV
# with R:
LdaCV.iris <- lda(iris2, species.name, CV=TRUE)  # specify the argument CV
LdaCV.iris$class
species.name
table(class.true=species.name, class.assignedCV=LdaCV.iris$class)
errorsCV <- (LdaCV.iris$class != species.name)
errorsCV
sum(errorsCV)
AERCV   <- sum(errorsCV)/length(species.name)
AERCV
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
# Plot the partition induced by LDA
plot.partition.lda <- function() {
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col='red', pch=20)
points(iris2[i2,], col='green', pch=20)
points(iris2[i3,], col='blue', pch=20)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'), cex=.7)
points(lda.iris$means, pch=4,col=c('red','green','blue') , lwd=2, cex=1.5)
z  <- predict(lda.iris, xy)$post  # these are P_i*f_i(x,y)
z1 <- z[,1] - pmax(z[,2], z[,3])  # P_1*f_1(x,y)-max{P_j*f_j(x,y)}
z2 <- z[,2] - pmax(z[,1], z[,3])  # P_2*f_2(x,y)-max{P_j*f_j(x,y)}
z3 <- z[,3] - pmax(z[,1], z[,2])  # P_3*f_3(x,y)-max{P_j*f_j(x,y)}
# Plot the contour line of level (levels=0) of z1, z2, z3:
# P_i*f_i(x,y)-max{P_j*f_j(x,y)}=0 i.e., boundary between R.i and R.j
# where j realizes the max.
contour(x, y, matrix(z1, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z2, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z3, 200), levels=0, drawlabels=F, add=T)
}
plot.partition.lda()
library(rgl)
library(mvtnorm)
open3d()
points3d(iris2[i1,1], iris2[i1,2], 0, col='red', pch=15)
points3d(iris2[i2,1], iris2[i3,2], 0, col='green', pch=15)
# Plot the partition induced by LDA
plot.partition.lda <- function() {
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col='red', pch=20)
points(iris2[i2,], col='green', pch=20)
points(iris2[i3,], col='blue', pch=20)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'), cex=.7)
points(lda.iris$means, pch=4,col=c('red','green','blue') , lwd=2, cex=1.5)
z  <- predict(lda.iris, xy)$post  # these are P_i*f_i(x,y)
z1 <- z[,1] - pmax(z[,2], z[,3])  # P_1*f_1(x,y)-max{P_j*f_j(x,y)}
z2 <- z[,2] - pmax(z[,1], z[,3])  # P_2*f_2(x,y)-max{P_j*f_j(x,y)}
z3 <- z[,3] - pmax(z[,1], z[,2])  # P_3*f_3(x,y)-max{P_j*f_j(x,y)}
# Plot the contour line of level (levels=0) of z1, z2, z3:
# P_i*f_i(x,y)-max{P_j*f_j(x,y)}=0 i.e., boundary between R.i and R.j
# where j realizes the max.
contour(x, y, matrix(z1, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z2, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z3, 200), levels=0, drawlabels=F, add=T)
}
plot.partition.lda()
library(rgl)
library(mvtnorm)
open3d()
points3d(iris2[i1,1], iris2[i1,2], 0, col='red', pch=15)
points3d(iris2[i2,1], iris2[i3,2], 0, col='green', pch=15)
points3d(iris2[i3,1], iris2[i2,2], 0, col='blue', pch=15)
surface3d(x, y, dmvnorm(xy, m1, Sp) / 3, alpha=0.4, color='red')
surface3d(x, y, dmvnorm(xy, m2, Sp) / 3, alpha=0.4, color='green', add=T)
surface3d(x, y, dmvnorm(xy, m3, Sp) / 3, alpha=0.4, color='blue', add=T)
box3d()
help(qda)
qda.iris <- qda(iris2, species.name)
qda.iris
Qda.iris <- predict(qda.iris, iris2)
# compute the APER
Qda.iris$class
species.name
table(class.true=species.name, class.assigned=Qda.iris$class)
errorsq <- (Qda.iris$class != species.name)
errorsq
APERq   <- sum(errorsq)/length(species.name)
APERq
(15+13+1)/150
# Compute the estimate of the AER by leave-one-out cross-validation
QdaCV.iris <- qda(iris2, species.name, CV=T)
QdaCV.iris$class
species.name
table(class.true=species.name, class.assignedCV=QdaCV.iris$class)
errorsqCV <- (QdaCV.iris$class != species.name)
errorsqCV
AERqCV   <- sum(errorsqCV)/length(species.name)
AERqCV
# Plot the partition induced by QDA
plot.partition.qda <- function() {
plot(iris2, main='Iris Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col='red', pch=20)
points(iris2[i2,], col='green', pch=20)
points(iris2[i3,], col='blue', pch=20)
legend("topright", legend=levels(species.name), fill=c('red','green','blue'))
points(qda.iris$means, col=c('red','green','blue'), pch=4, lwd=2, cex=1.5)
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
z  <- predict(qda.iris, xy)$post
z1 <- z[,1] - pmax(z[,2], z[,3])
z2 <- z[,2] - pmax(z[,1], z[,3])
z3 <- z[,3] - pmax(z[,1], z[,2])
contour(x, y, matrix(z1, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z2, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z3, 200), levels=0, drawlabels=F, add=T)
}
plot.partition.qda()
open3d()
points3d(iris2[i1,1], iris2[i1,2], 0, col='red', pch=15)
points3d(iris2[i2,1], iris2[i3,2], 0, col='green', pch=15)
points3d(iris2[i3,1], iris2[i2,2], 0, col='blue', pch=15)
surface3d(x, y, dmvnorm(xy, m1, S1) / 3, alpha=0.4, color='red')
surface3d(x, y, dmvnorm(xy, m2, S2) / 3, alpha=0.4, color='green', add=T)
surface3d(x, y, dmvnorm(xy, m3, S3) / 3, alpha=0.4, color='blue', add=T)
box3d()
k <- 12
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
k <- 3
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
k <- 5
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
k <- 2
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
true <- read.table('moneytrue.txt', header=TRUE)
k <- 13
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
k <- 20
plot(iris2, main='Iris.Sepal', xlab='Sepal.Length', ylab='Sepal.Width', pch=20)
points(iris2[i1,], col=2, pch=20)
points(iris2[i3,], col=4, pch=20)
points(iris2[i2,], col=3, pch=20)
legend("topright", legend=levels(species.name), fill=c(2,3,4))
x  <- seq(min(iris[,1]), max(iris[,1]), length=200)
y  <- seq(min(iris[,2]), max(iris[,2]), length=200)
xy <- expand.grid(Sepal.Length=x, Sepal.Width=y)
iris.knn <- knn(train = iris2, test = xy, cl = iris$Species, k = k)
z  <- as.numeric(iris.knn)
contour(x, y, matrix(z, 200), levels=c(1.5, 2.5), drawlabels=F, add=T)
true <- read.table('moneytrue.txt', header=TRUE)
true <- read.table('moneytrue.txt', header=TRUE)
false <- read.table('moneyfalse.txt', header=TRUE)
banknotes <- rbind(true,false)
vf <- factor(rep(c('true','false'),each=100), levels=c('true','false'))
plot(banknotes[,1:2], main='Banknotes', xlab='V1', ylab='V2', pch=20)
points(false, col='red', pch=20)
points(true, col='blue', pch=20)
legend('bottomleft', legend=levels(vf), fill=c('blue','red'), cex=.7)
# question a)
library(MVN)
mvn(true)$multivariateNormality
mvn(false)$multivariateNormality
# misclassification costs
c.tf <- 10
c.ft <- 0.05
#prior probabilities
pf <- 0.001
pt <- 1-0.001
prior = c(pt, pf)
prior
# Prior modified to account for the misclassification costs
prior.c <- c(pt*c.ft/(c.tf*pf+c.ft*pt), pf*c.tf/(c.tf*pf+c.ft*pt))
prior.c
# QDA
qda.m <- qda(banknotes, vf, prior=prior.c)
qda.m
plot(banknotes[,1:2], main='Banknotes', xlab='V1', ylab='V2', pch=20)
points(false, col='red', pch=20)
points(true, col='blue', pch=20)
legend('bottomleft', legend=levels(vf), fill=c('blue','red'), cex=.7)
points(qda.m$means, pch=4,col=c('red','blue') , lwd=2, cex=1.5)
x  <- seq(min(banknotes[,1]), max(banknotes[,1]), length=200)
y  <- seq(min(banknotes[,2]), max(banknotes[,2]), length=200)
xy <- expand.grid(V1=x, V2=y)
z  <- predict(qda.m, xy)$post
x  <- seq(min(banknotes[,1]), max(banknotes[,1]), length=200)
y  <- seq(min(banknotes[,2]), max(banknotes[,2]), length=200)
xy <- expand.grid(V1=x, V2=y)
z  <- predict(qda.m, xy)$post
z1 <- z[,1] - z[,2]
z2 <- z[,2] - z[,1]
contour(x, y, matrix(z1, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z2, 200), levels=0, drawlabels=F, add=T)
m1 <- colMeans(true)
m2 <- colMeans(false)
S1 <- cov(true)
S2 <- cov(false)
open3d()
# QDA
qda.m <- qda(banknotes, vf, prior=prior.c)
qda.m
plot(banknotes[,1:2], main='Banknotes', xlab='V1', ylab='V2', pch=20)
points(false, col='red', pch=20)
points(true, col='blue', pch=20)
legend('bottomleft', legend=levels(vf), fill=c('blue','red'), cex=.7)
points(qda.m$means, pch=4,col=c('red','blue') , lwd=2, cex=1.5)
x  <- seq(min(banknotes[,1]), max(banknotes[,1]), length=200)
y  <- seq(min(banknotes[,2]), max(banknotes[,2]), length=200)
xy <- expand.grid(V1=x, V2=y)
z  <- predict(qda.m, xy)$post
z1 <- z[,1] - z[,2]
z2 <- z[,2] - z[,1]
contour(x, y, matrix(z1, 200), levels=0, drawlabels=F, add=T)
contour(x, y, matrix(z2, 200), levels=0, drawlabels=F, add=T)
m1 <- colMeans(true)
m2 <- colMeans(false)
S1 <- cov(true)
S2 <- cov(false)
open3d()
points3d(true[,1], true[,2], 0, col='blue', pch=15)
points3d(false[,1], false[,2], 0, col='red', pch=15)
surface3d(x,y,matrix(dmvnorm(xy, m1, S1)*prior.c[1]/100 , 200), alpha=0.6, color='blue')
surface3d(x,y,matrix(dmvnorm(xy, m2, S2)*prior.c[2]/100 , 200), alpha=0.6, color='red', add=T)
box3d()
# question c)
# P[rejected] = P[rejected | true]P[true] + P[rejected | false]P[false]
2/100*pt + 20/100*pf
